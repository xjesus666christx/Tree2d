<!DOCTYPE html>
<html>
	<head><script src="classes.js"></script></head>
	<body onselectstart="return false"  oncontextmenu="return false">
		<div style="min-width:960px;width:77%;height:650px;overflow:scroll;float:left">
			<canvas id="myCanvas" width="512" height="512" style="border:1px solid #999999;">
				Your browser does not support the HTML5 canvas tag.
			</canvas>
		</div>
		<div style="min-width:260px;width:22%;height:650px;valign:top;float:left">
			<input type="button" value="Save"  onclick="ed.saveProject()" style="width:32%" />
			<input type="button" value="Load" onclick="document.getElementById('projectLoader').click()" style="width:32%" />
			<input type="button" value="Run" onclick="ed.runGame(this)" style="width:32%" />
			<select id="hierarhy" style="width:100%" onchange="ed.select(this.value)"></select>
			<div id="info" style="width:100%;height:40%;overflow:scroll"></div>
			<input type="button" value="Raise"  onclick="ed.raise()" style="width:32%" />
			<input type="button" value="Fall" onclick="ed.fall()" style="width:32%" />
			<input type="button" value="Delete" onclick="ed.del(ed.selected)" style="width:32%" />
			<input type="range" min="0" max="100" step="5" value="0" onchange="ed.setGrid(this)" /> Grid<br />
			<input type="range" min="0" max="20" value="0" onchange="ed.setBrushRandom(this)" /> Brush random<br />
			<input type="range" min="0" max="30" step="2" value="10" onchange="ed.setBrushDelay(this)" /> Brush delay<br />
			<div style="border:1px solid gray;width:100%;height:45%;cursor:default;">
				Assets: <input type="file" id="files" name="files[]" multiple /><br />
				<div id="assets" style="width:100%;height:85%;overflow-y:scroll"></div>
			</div>
			<input type="file" id="projectLoader" style="visibility:hidden;position:absolute;top:0;left:0" />
		</div>
	</body>
	<script>{
		var canvas, ctx;
		
		onload = function() {
			canvas = document.getElementById("myCanvas");
			canvas.addEventListener('mousedown', function(evt) {if (evt.button == 0) ed.mousePress(getMousePos(canvas, evt)); else ed.pick(getMousePos(canvas, evt));}, false);
			canvas.addEventListener('mousemove', function(evt) {if (evt.button == 0) ed.mouseMove(getMousePos(canvas, evt)); else ed.drag(getMousePos(canvas, evt));}, false);
			canvas.addEventListener('mouseup',   function(evt) {if (evt.button == 0) ed.mouseRelease(getMousePos(canvas, evt)); else ed.unpick();}, false);
			canvas.addEventListener('mouseout',   function(evt) {if (evt.button == 0) ed.mouseRelease(0); else ed.unpick();}, false);
			ctx = canvas.getContext("2d");
			document.getElementById('files').addEventListener('change', ed.load, false);
			document.getElementById('projectLoader').addEventListener('change', ed.loadProject, false);
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 2;
			ed.select(0);
			ed.renewHierarhy();
			ed.addAssetFromString('node.json', '{"class":"Node"}');
			setInterval(ed.cycle, 10);
		}
		
		// основная либа для работы с внутриигровым деревом
		// для содержания дерева есть 2 типа связей:
		// 1. потомки node хранятся в массиве node.c
		// 2. у node есть ссылки на parent (родителя), child (первого потомка) и next (соседа)
		var Tree2d = {
			// корневой узел
			root: {
				x:0,  // позиция по Х
				y:0,  // позиция по Y
				r:0,  // поворот в градусах
				zx:1, // масштаб по горизонтали (1 - изначальный, 0.5 - в 2 раза меньше)
				zy:1, // масштаб по вертикали
				w:512, // ширина (прилаги)
				h:512, // высота (прилаги)
				a:1,  // степень непрозрачности (1 - непрозрачный, 0 - полностью прозрачный)
				id:0, // уникальный ID, по нему осуществляется поиск
				name:'root' // имя узла (по нему тоже можно искать узел в дереве)
			},
			
			cid: 1, // текущий айдишник
			
			// генерирует уникальный айдишник - имя узла
			genId: function() {
				return Tree2d.cid++;
			},
			
			// возвращает копию указанного узла
			// рекурсивная
			copy: function(node) {
				var copy = {};
				for (i in node) {
					if (typeof node[i] === 'object' || i == 'id') {
					} else {
						copy[i] = node[i];
					}
				}
				if (node && node.c) {
					copy.c = [];
					for (i in node.c) {
						if (node.c[i]) copy.c[i] = Tree2d.copy(node.c[i]);
					}
				}
				return copy;
			},
			
			// создает дефолтные поля, если их нет
			// вызывает для каждой ноды ф-ю инициализации - имя класса
			// создает в узле ссылки на родителя, соседа и потомка
			// рекурсивная
			init: function(node) {
				if (!node.x) node.x = 0;
				if (!node.y) node.y = 0;
				if (!node.r) node.r = 0;
				if (!node.zx) node.zx = 1;
				if (!node.zy) node.zy = 1;
				if (!node.w) node.w = 0;
				if (!node.h) node.h = 0;
				if (!node.a) node.a = 1;
				if (!node.id) node.id = Tree2d.genId();
				if (node.class) {
					try {
						var f = eval(node.class);
						f(node);
					} catch (e) {}
				} else node.class = "Node";
				if (node.c) {
					var prev;
					for (i in node.c) {
						var val = node.c[i];
						if (!val) console.log(node);
						if (!val.parent) val.parent = node;
						if (!prev) node.child = val;
						else prev.next = val;
						prev = val;
						Tree2d.init(val);
					}
				}
			},
			
			// удаляет из узла дефолтные поля
			// удаляет все внутренние объекты, кроме массива c[] (children)
			// рекурсивная
			clean: function(node) {
				if (node.x == 0) delete node.x;
				else node.x = Math.floor(node.x);
				if (node.y == 0) delete node.y;
				else node.y = Math.floor(node.y);
				if (node.r == 0) delete node.r;
				else node.r = Math.floor(node.r);
				if (node.zx == 1) delete node.zx;
				if (node.zy == 1) delete node.zy;
				if (node.a == 1) delete node.a;
				if (node.w == 0) delete node.w;
				if (node.h == 0) delete node.h;
				if (node.id) delete node.id;
				for (i in node) {
					if (typeof node[i] === 'number') {
						node[i] = parseFloat(node[i].toFixed(4));
					} else if (i != 'c' && typeof node[i] === 'object') {
						node[i] = 0;
						delete node[i];
					}
				}
				for (i in node.c) {
					if (node.c[i]) Tree2d.clean(node.c[i]);
					else delete node.c[i];
				}
				return node;
			},
			
			// добавляет node в массив с (children) родителя
			// перестраивает ссылки на следующий элемент среди потомков parent
			// инициализирует node
			add: function(parent, node) {
				node = Tree2d.copy(node) || {};
				
				if (!parent.c) parent.c = [];
				parent.c.push(node);
				node.parent = parent;
				
				if (!parent.child) {
					parent.child = node;
				} else {
					var c = parent.child;
					while (c.next) c = c.next;
					c.next = node;
				}
				Tree2d.init(node);
				
				return node;
			},
			
			// удаляет node из потомков его родителя
			del: function(node) {
				var parent = node.parent;
				if (parent) {
					for (i in parent.c) {
						if (parent.c[i] == node) {
							parent.c[i] = 0;
							delete parent.c[i];
							break;
						}
					}
					if (parent.child == node) {
						parent.child = node.next;
					} else {
						var c = parent.child;
						while (c.next && c.next != node) c = c.next;
						c.next = node.next;
					}
				}
			},
			
			// всем потомкам родителя node, кроме node, выставляет opacity = 0
			select: function(node) {
				var c = node.parent.child;
				while (c) {
					if (c != node) c.a = 0;
					else if (c.a == 0) c.a = 1;
					c = c.next;
				}
			},
			
			cookUpdate: function(node) {
				if (!node.e) return;
				
				var str = '(function(n) {\n', cnt = 0;
				for (i in node.e) {
					if (i == 'init') continue;
					var line = node.e[i];
					line = line.split(';').join('\n');
					for (j in node) {
						if (typeof node[j] == 'number') {
							line = line.split(j).join('n.'+j);
						}
					}
					for (j in Tree2d) {
						line = line.split(j).join('Tree2d.'+j);
					}
					str += line;
					cnt++;
				}
				str += '\n})';
				
				if (cnt > 0) {
					console.log('update: ' + str);
					node.update = eval(str);
				}
				
				if (node.e.init) {
					var str = '(function(n) {\n';
					var line = node.e.init;
					line = line.split(';').join('\n');
					for (j in node) {
						if (typeof node[j] == 'number') {
							line = line.split(j).join('n.'+j);
						}
					}
					for (j in Tree2d) {
						line = line.split(j).join('Tree2d.'+j);
					}
					str += line + '\n})';
					
					console.log('init: ' + str);
					node.init = eval(str);
				}
			},
			
			// действия за 1 кадр: отрисовка и апдейт
			cycle: function() {
				var n = Tree2d.root;
				ctx.save();
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.translate(canvas.width / 2, canvas.height / 2);
				while (n) {
					ctx.save();
					ctx.globalAlpha *= n.a;
					ctx.translate(n.x, n.y);
					ctx.rotate(n.r / 180 * Math.PI);
					ctx.scale(n.zx, n.zy);
					if (n.a) {
						if (n.update) n.update(n);
						if (n.draw) n.draw(n);
					}
					
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							ctx.globalAlpha /= n.a;
							ctx.restore();
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				ctx.restore();
			},
			
			// если узел с ID id не найден - вернет undefined
			findById: function(id) {
				var n = Tree2d.root;
				
				while (n) {
					if (n.id == id) {
						return n;
					} else if (n.child) {
						n = n.child;
					} else {
						while (n) {
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
			},
			
			// если узел с именем name не найден - вернет undefined
			findByName: function(name) {
				var n = Tree2d.root;
				
				while (n) {
					if (n.name == name) {
						return n;
					} else if (n.child) {
						n = n.child;
					} else {
						while (n) {
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
			},
			
			// получить позицию, поворот, скейл и непрозрачность отрисовки узла
			getScreenTransform: function(node) {
				var trans = {x:0,y:0,zx:1,zy:1,r:0};
				var parent = node.parent;
				var x = node.x, y = node.y;
				var r = node.r;
				var zx = node.zx, zy = node.zy;
				
				while (parent) {
					var si = Math.sin(parent.r * Math.PI / 180);
					var co = Math.cos(parent.r * Math.PI / 180);
					trans.x = parent.x + (x*parent.zx*co - y*parent.zy*si);
					trans.y = parent.y + (x*parent.zx*si + y*parent.zy*co);
					trans.r = parent.r + r;
					trans.zx = parent.zx * zx;
					trans.zy = parent.zy * zy;
					
					x = trans.x;
					y = trans.y;
					r = trans.r;
					zx = trans.zx;
					zy = trans.zy;
					
					parent = parent.parent;
				}
				
				return trans;
			},
			
			// если бы точка была узлом и рисовалась бы в (pos.x, pos.y),
			// то внутри node она имела бы позицию, поворот, скейл и непрозрачность,
			// возвращенные этой ф-ей
			convertPointToNodeTransform: function(node, pos) {
				var t = Tree2d.getScreenTransform(node);
				var dx = pos.x - t.x;
				var dy = pos.y - t.y;
				var d = Math.sqrt(dx * dx + dy * dy);
				var r = Math.atan2(dy, dx) / Math.PI * 180;
				var si = Math.sin((t.r-r) * Math.PI / 180);
				var co = Math.cos((t.r-r) * Math.PI / 180);
				var x = d * co;
				var y = d * si;
				return {x:x / t.zx, y:-y / t.zy};
			},
			
			// тут все просто: находит кликнутый объект
			// если такого нет - возвращает undefined
			getClickedObject: function(pos) {
				var n = Tree2d.root;
				var arr = [];
				
				while (n) {
					if (n.a && n.w && n.w) arr.push(n);
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				
				arr = arr.reverse();
				for (i in arr) {
					n = arr[i];
					var t = Tree2d.getScreenTransform(n);
					var si = Math.sin(t.r * Math.PI / 180);
					var co = Math.cos(t.r * Math.PI / 180);
					var xp = [];
					var yp = [];
					var w = n.w / 2, h = n.w / 2;
					xp.push(t.x + t.zx * w * co - t.zy * h * si);
					yp.push(t.y + t.zx * w * si + t.zy * h * co);
					w = -w;
					xp.push(t.x + t.zx * w * co - t.zy * h * si);
					yp.push(t.y + t.zx * w * si + t.zy * h * co);
					h = -h;
					xp.push(t.x + t.zx * w * co - t.zy * h * si);
					yp.push(t.y + t.zx * w * si + t.zy * h * co);
					w = -w;
					xp.push(t.x + t.zx * w * co - t.zy * h * si);
					yp.push(t.y + t.zx * w * si + t.zy * h * co);
					
					if (pnpoly(4, xp, yp, pos.x, pos.y)) return n;
				}
			},
			
			// делает node на слой выше соседей
			// влияет на порядок отрисовки, апдейта, нахождения кликнутого узла
			raise: function(node) {
				if (node.next) Tree2d.fall(node.next);
			},
			
			// делает node на слой ниже соседей
			// влияет на порядок отрисовки, апдейта, нахождения кликнутого узла
			fall: function(node) {
				if (!node.parent) return;
				var p = node.parent, i, j;
				for (i in p.c) {
					if (p.c[i] == node) break;
					j = i;
				}
				if (j) {
					var c = p.c[i];
					p.c[i] = p.c[j];
					p.c[j] = c;
					for (i in p.c) if (p.c[i].next) delete p.c[i].next;
					
					var prev;
					for (i in p.c) {
						var val = p.c[i];
						if (!val.parent) val.parent = p;
						if (!prev) p.child = val;
						else prev.next = val;
						prev = val;
					}
				}
			}
		}
		
		// ф-ии редактора
		var ed = {
			run: false, // запущена прилага или нет
			root: Tree2d.root, // корень, может меняться
			selected: undefined, // выделенный объект
			images: {}, // хранилище картинок (для избежания дубликатов)
			assets: {}, // хранилище ассетов (готовые узлы)
			selectedAssets: {}, // выделенные ассеты
			selectedAssetsCnt: 0, // их число
			eventTypes: ['update', 'click', 'init', 'destroy'], // типы возможных событий
			brush: { // параметры кисти
				timeout:10, // задержка действия
				ready:true,
				grid:0, // высота и ширина сетки
				random:0, // разброс относительно позиции в сетке
				drag:false, // тянем?
				t:0 // таймер, обслуживающий задержку
			},
			pickup: false,
			
			// грузит картинку, избегает дубликатов
			loadImage: function(name) {
				if (ed.images[name]) return ed.images[name];
				ed.images[name] = new Image;
				ed.images[name].src = name;
				if (!ed.assets[name]) ed.loadSprite(name);
				return ed.images[name];
			},
			
			// "вписывает" картинку img в квадрат size*size
			alignAssetSize: function(img, size) {
				var d = img.width / img.height;
				if (img.width > img.height) {
					img.width = size;
					img.height = size / d;
					img.vspace = size / 2 - img.height / 2;
				} else {
					img.height = size;
					img.width = size * d;
					img.hspace = size / 2 - img.width / 2;
				}
			},
			
			// выделить ассет с именем name
			selectAsset: function(name) {
				if (!ed.selectedAssets[name]) {
					ed.selectedAssets[name] = ed.assets[name];
					ed.selectedAssetsCnt++;
					document.getElementById(name).style.border = "2px solid #6468D1";
				} else {
					ed.selectedAssets[name] = 0;
					delete ed.selectedAssets[name];
					ed.selectedAssetsCnt--;
					document.getElementById(name).style.border = "2px solid #f7f4a0";
				}
			},
			
			// грузит картинку, создает ассет с именем name
			loadSprite: function(name) {
				if (ed.assets[name]) return ed.assets[name];
				
				ed.assets[name] = {src: name, class: 'Sprite'};
				ed.loadImage(name);
				
				document.getElementById('assets').innerHTML += '<div id="'+name+'" title="'+name+'" style="float:left; width:60px; height:60px; border:2px solid #f7f4a0; background-color:white;" onclick="ed.selectAsset(\''+name+'\')" ><img src="'+name+'" ondblclick="ed.placeAsset(\''+name+'\')" onload="ed.alignAssetSize(this, 60)" /></div>';
				return ed.assets[name];
			},
			
			// создает ассет из строки, содержащей JSON
			addAssetFromString: function(name, str) {
				var node = JSON.parse(str);
				ed.assets[name] = node;
				
				var withoutExt = name.substr(0, name.lastIndexOf('.'));
				withoutExt = withoutExt.charAt(0).toUpperCase() + withoutExt.substr(1);
				document.getElementById('assets').innerHTML += '<div id= "'+name+'" title="'+name+'" style="float:left; width:60px; height:60px; border:2px solid #f7f4a0; background-color:white; font-size: small; text-align:center;" ondblclick="ed.placeAsset(\''+name+'\')" onclick="ed.selectAsset(\''+name+'\')" ><br />'+withoutExt+'</div>';
			},
			
			// грузит узел из файла, создает соотв. ассет с именем name
			loadNode: function(name, file) {
				if (ed.assets[name]) return ed.assets[name];
				
				var reader = new FileReader();
				reader.onload = function(e) {
					ed.addAssetFromString(name, e.target.result);
				}
				var result = reader.readAsText(file);
				
				return ed.assets[name];
			},
			
			// загрузить что-то
			load: function(evt) {
				var files = evt.target.files;
				for (var i = 0, f; f = files[i]; i++) {
					var name = f.name.substr(f.name.lastIndexOf('/') + 1);
					if (f.type == 'image/png' || f.type == 'image/jpeg') {
						ed.loadSprite(name);
					} else if (f.type == 'application/json') {
						ed.loadNode(name, f);
					}
				}
			},
			
			// загружает узел, устанавливает его в качестве корня
			loadProject: function(evt) {
				var file = evt.target.files[0];
				var withoutExt = file.name.substr(0, file.name.lastIndexOf('.'));
				
				var reader = new FileReader();
				reader.onload = function(e) {
					var node = JSON.parse(e.target.result);
					Tree2d.init(node);
					ed.root = Tree2d.root = node;
					
					ed.renewHierarhy();
					ed.select(node.id);
					
					canvas.width = node.w;
					canvas.height = node.h;
				}
				var result = reader.readAsText(file);
			},
			
			// выплевывает файл .json, названный как корень, содержащий иерархию сцены в JSON
			saveProject: function() {
				var text = JSON.stringify(Tree2d.clean(Tree2d.copy(Tree2d.root)));
				var pom = document.createElement('a');
				pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
				pom.setAttribute('download', ed.root.name + '.json');
				pom.setAttribute('type', 'application/json');
				pom.click();
			},
			
			// обрабатывает нажатие левой кнопки мыши
			mousePress: function(pos) {
				if (ed.selectedAssetsCnt == 0) {
					ed.pickup = true;
					if (ed.selected.parent) {
						ed.tmpMousePos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
						ed.tmpSelectedTrans = {x: ed.selected.x, y: ed.selected.y, r: ed.selected.r, zx: ed.selected.zx, zy:ed.selected.zy};
					}
				} else {
					ed.brush.drag = true;
					if (!ed.brush.grid) ed.brush.grid = 1;
					if (!ed.grid) ed.grid = 1;
					if (ed.selected != ed.root) pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					pos.x = Math.floor((pos.x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
					pos.y = Math.floor((pos.y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
					pos.x += Math.random() * ed.brush.random * 2 - ed.brush.random;
					pos.y += Math.random() * ed.brush.random * 2 - ed.brush.random;
					ed.brush.dragPos = pos;
					ed.pasteAsset(pos);
					ed.brush.t = ed.brush.timeout;
				}
			},
			
			// перемещение мыши с удержанной левой кнопкой
			mouseMove: function(pos) {
				if (ed.pickup && ed.selected.parent) {
					if (!ed.brush.grid) ed.brush.grid = 1;
					pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					if (event.shiftKey) {
						var dx1 = ed.tmpMousePos.x - ed.tmpSelectedTrans.x;
						var dy1 = ed.tmpMousePos.y - ed.tmpSelectedTrans.y;
						var d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
						var dx2 = pos.x - ed.tmpSelectedTrans.x;
						var dy2 = pos.y - ed.tmpSelectedTrans.y;
						var d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
						var d = d2 / d1;
						ed.set('zx', ed.tmpSelectedTrans.zx * d);
						ed.set('zy', ed.tmpSelectedTrans.zy * d);
					} else if (event.ctrlKey) {
						var r = Math.atan2(pos.y - ed.tmpSelectedTrans.y, pos.x - ed.tmpSelectedTrans.x) / Math.PI * 180;
						ed.set('r', ed.tmpSelectedTrans.r + r);
					} else {
						var x = ed.tmpSelectedTrans.x + (pos.x - ed.tmpMousePos.x);
						var y = ed.tmpSelectedTrans.y + (pos.y - ed.tmpMousePos.y);
						var x1 = Math.floor((x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						var y1 = Math.floor((y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						if (Math.abs(x1 - x) < 10) x = x1;
						if (Math.abs(y1 - y) < 10) y = y1;
						ed.set('x', x);
						ed.set('y', y);
					}
				} else if (ed.brush.drag && ed.brush.ready) {
					if (ed.brush.t > 0) {
						ed.brush.t--;
						return;
					}
					if (ed.selected != ed.root) pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					if (Math.abs(pos.x - ed.brush.dragPos.x) > ed.brush.grid * 0.75 || Math.abs(pos.y - ed.brush.dragPos.y) > ed.brush.grid * 0.75) {
						if (!ed.grid) ed.grid = 1;
						pos.x = Math.floor((pos.x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						pos.y = Math.floor((pos.y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						pos.x += Math.random() * ed.brush.random* 2 - ed.brush.random;
						pos.y += Math.random() * ed.brush.random * 2 - ed.brush.random;
						ed.brush.dragPos = pos;
						ed.pasteAsset(pos);
					}
					ed.brush.t = ed.brush.timeout;
				}
			},
			
			// отпускание левой кнопки мыши
			mouseRelease: function(pos) {
				ed.brush.drag = false;
				ed.pickup = false;
			},
			
			// нажатие правой кнопки мыши
			pick: function(pos) {
				var c = Tree2d.getClickedObject(pos);
				if (ed.selectedAssetsCnt == 0) {
					if (c) ed.select(c.id);
					else ed.select(Tree2d.root.id);
				} else {
					if (c && c.parent == ed.selected) ed.del(c);
				}
			},
			
			// "перетаскивание" с нажатой правой кнопкой мыши
			drag: function(pos) {
				if (ed.selectedAssetsCnt != 0) {
					var c = Tree2d.getClickedObject(pos);
					if (c && c.parent == ed.selected) ed.del(c);
				}
			},
			
			// отпускание правой кнопки мыши
			unpick: function() {
			},
			
			// вставляет один из выделенных ассетов в выделенный узел на позиции pos
			pasteAsset: function(pos) {
				var c = getRandField(ed.selectedAssets);
				pos = Tree2d.convertPointToNodeTransform(ed.selected, pos);
				c.x = pos.x;
				c.y = pos.y;
				Tree2d.add(ed.selected, c);
				ed.renewHierarhy();
			},
			
			// удаляет узел c из иерархии
			del: function(c) {
				if (!c.parent) return;
				if (c == ed.selected) ed.select(ed.selected.parent.id);
				Tree2d.del(c);
				ed.renewHierarhy();
			},
			
			// устанавливает размер сетки input.value
			setGrid: function(input) {
				ed.brush.grid = parseFloat(input.value);
				input.title = ed.brush.grid;
			},
			
			// устанавливает задержку кисти input.value
			setBrushDelay: function(input) {
				ed.brush.timeout = parseFloat(input.value);
				input.title = ed.brush.timeout;
			},
			
			// устанавливает разброс кисти input.value
			setBrushRandom: function(input) {
				ed.brush.random = parseFloat(input.value);
				input.title = ed.brush.random;
			},
			
			// поднимает выделенную ноду наверх (вниз по иерархии)
			raise: function() {
				Tree2d.fall(ed.selected);
				ed.renewHierarhy();
				ed.select(ed.selected.id);
			},
			
			// опускает выделенную ноду на слой ниже (вверх по иерархии)
			fall: function(node) {
				Tree2d.raise(ed.selected);
				ed.renewHierarhy();
			},
			
			// обновляет выпадающий список иерархии
			renewHierarhy: function() {
				var n = Tree2d.root, str = '', t = -1;
				
				while (n) {
					t++;
					
					var s = '', i = 0;
					for (i = 0; i < t; i++) s += '-';
					var name = n.name;
					if (!n.name || name == '')  name = '';
					else name = ' ' + name;
					if (n.class) name += ' [' + n.class + ']';
					else name += ' [Node]';
					str += '<option value="' + n.id + '">' + s + name + '</option>\n';
					
					if (n.child) {
						n = n.child;
					} else {
						while (n) {
							t--;
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				
				document.getElementById('hierarhy').innerHTML = str;
				document.getElementById('hierarhy').value = ed.selected.id;
			},
			
			// выделяет ноду с ID = id
			select: function(id) {
				id = parseFloat(id);
				ed.selected = Tree2d.findById(id);
				document.getElementById('hierarhy').value = id;
				ed.updateInfo();
			},
			
			// устанавливает параметр param выделенной ноды равным value
			set: function(param, value) {
				var node = ed.selected;
				if (typeof(value) === 'boolean') {
					node[param] = (value?1:0);
					document.getElementById('edit-'+param).value = node[param];
					document.getElementById('edit-'+param+'-checkbox').checked = (node[param]>0?true:false);
				} else if (typeof node[param] === 'number') {
					if (typeof parseFloat(value) === 'number') {
						node[param] = parseFloat(value);
						if (node == ed.root && (param == 'w' || param == 'h')) {
							canvas.width = node.w;
							canvas.height = node.h;
						}
					}
					document.getElementById('edit-'+param).value = node[param];
					if (document.getElementById('edit-'+param+'-checkbox')) document.getElementById('edit-'+param+'-checkbox').checked = (node[param]>0?true:false);
				} else node[param] = value;
				if (param == 'name') ed.renewHierarhy();
			},
			
			// обновляет блок информации о ноде
			updateInfo: function() {
				var node = ed.selected;
				var excluded = ['id', 'src', 'class'];
				var str = '\
				<input type="text" value="Name" readonly style="width:80px" /><input type="text" onclick="this.select()" onchange="ed.set(\'name\',this.value)" id="edit-name" value="'+(node.name?node.name:'')+'" /><br />\
				<input type="text" value="Position" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'x\',this.value)" id="edit-x" value="'+node.x+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'y\',this.value)" id="edit-y" value="'+node.y+'" /><br />\
				<input type="text" value="Scale" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'zx\',this.value)" id="edit-zx" value="'+node.zx+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'zy\',this.value)" id="edit-zy" value="'+node.zy+'" /><br />\
				<input type="text" value="Bounds" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'w\',this.value)" id="edit-w" value="'+node.w+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'h\',this.value)" id="edit-h" value="'+node.h+'" /><br />\
				<input type="text" value="Rotation" readonly style="width:80px" /><input type="number" onclick="this.select()" onchange="ed.set(\'r\',this.value)" id="edit-r" value="'+node.r+'" /><br />\
				<input type="text" value="Opacity" readonly style="width:80px" /><input type="range" onchange="ed.set(\'a\',this.value)" id="edit-a" min="0" max="1" step="0.05" value="'+node.a+'" />\
				<input type="checkbox" onclick="this.select()" onchange="ed.set(\'a\',this.checked)" id="edit-a-checkbox" '+(node.a>0?"checked":"")+' /><br />';
				
				str += 'Other attributes:<br /><table>';
				for (i in node) {
					var flag = false;
					for (j in excluded) if (i == excluded[j]) flag = true;
					if (flag) continue;
					if (i == 'x' || i == 'y' || i == 'r' || i == 'zx' || i == 'zy' || i == 'a' || i == 'w' || i == 'h') {
					} else if (typeof node[i] == 'number' && i != 'id') {
						var name = i;
						str += '<tr><td><input type="text" value="'+name+'" readonly style="width:80px" /></td><td><input type="number" onclick="this.select()" onchange="ed.set(\''+i+'\',this.value)" id="edit-'+i+'" value='+node[i]+' /></td><td><input type="button" value="-" onclick="ed.deleteAttr(\''+name+'\')"></td></tr>';
					}
				}
				for (i in node) {
					var flag = false;
					for (j in excluded) if (i == excluded[j]) flag = true;
					if (flag) continue;
					if (typeof node[i] == 'string' && i != 'name') {
						var name = i;
						str += '<tr><td>'+name+'</td><td><input type="text" onclick="this.select()" onchange="ed.set(\''+i+'\',this.value)" id="edit-'+i+'" value='+node[i]+' /></td></tr>';
					}
				}
				str += '</table><input id="addAttributeName" type="text" placeholder="key" onkeydown="ed.trySubmit(event, \'addAttrBtn\')" /><input id="addAttrBtn" type="button" value="Add" onclick="ed.addAttribute()" /><br />';
				
				str += 'Events:<br /><table>';
				excluded = [];
				if (node.e) {
					for (i in node.e) {
						str += '<tr><td><input type="text" value="'+i+'" readonly style="width:80px" /></td><td><input type="text" onclick="this.select()" onchange="ed.setEvent(\''+i+'\', this.value)" value='+node.e[i]+' /></td><td><input type="button" value="-" onclick="ed.deleteEvent(\''+i+'\')"></td></tr>';
						excluded.push(i);
					}
				}
				str += '</table><select id="addEventType">'
				for (i in ed.eventTypes) {
					var name = ed.eventTypes[i];
					var flag = true;
					for (j in excluded) {
						if (name == excluded[j]) flag = false;
					}
					if (!flag) continue;
					str += '<option value="'+name+'">'+name+'</option>';
				}
				str += '</select><input type="button" value="Add" onclick="ed.addEvent()" />';
				
				document.getElementById('info').innerHTML = str;
				
				Tree2d.cookUpdate(node);
			},
			
			setEvent: function(name, val) {
				ed.selected.e[name] = val;
				Tree2d.cookUpdate(ed.selected);
			},
			
			deleteEvent: function(name) {
				delete ed.selected.e[name];
				ed.updateInfo();
			},
			
			addEvent: function() {
				var name = document.getElementById('addEventType').value;
				if (!ed.selected.e) ed.selected.e = {};
				ed.selected.e[name] = '';
				ed.updateInfo();
			},
			
			deleteAttr: function(name) {
				delete ed.selected[name];
				ed.updateInfo();
			},
			
			trySubmit: function(event, id) {
				if (event.keyCode == 13) {
					document.getElementById(id).click();
				}
			},
			
			addAttribute: function() {
				var name = document.getElementById('addAttributeName').value;
				var excluded = ['x', 'y', 'r', 'w', 'h', 'zx', 'zy', 'a', 'src', 'id', 'class'];
				for (i in excluded) {
					if (excluded[i] == name) {
						alert('Attribute name '+name+' is reserved.');
						return;
					}
				}
				ed.selected[name] = 0;
				ed.updateInfo();
			},
			
			// вставляет ассет с именем name в выделенную ноду на позиции (0, 0)
			placeAsset: function(name) {
				var c = Tree2d.add(ed.selected, ed.assets[name]);
				ed.select(c.id);
				ed.renewHierarhy();
			},
			
			// действия за кадр: отрисовка и мб обработка
			cycle: function() {
				var n = ed.root;
				ctx.save();
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.translate(canvas.width / 2, canvas.height / 2);
				while (n) {
					ctx.save();
					ctx.translate(n.x, n.y);
					ctx.rotate(n.r / 180 * Math.PI);
					ctx.scale(n.zx, n.zy);
					if (n.a) {
						if (ed.run && n.update) n.update(n);
						if (n.debugDraw) n.debugDraw(n);
						else if (n.draw) n.draw(n);
					}
					
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							if (!ed.run) {
								ctx.strokeRect(-n.w / 2 - 1, -n.h / 2 - 1, n.w + 1, n.h + 1);
								if (n == ed.selected) {
									ctx.beginPath();
									ctx.moveTo(-n.w / 2, -n.h / 2);
									ctx.lineTo(n.w / 2, n.h / 2);
									ctx.moveTo(-n.w / 2, n.h / 2);
									ctx.lineTo(n.w / 2, -n.h / 2);
									ctx.stroke();
								}
								if (n == ed.selected && n.c) {
									ctx.lineWidth = 1;
									ctx.beginPath();
									for (i in n.c) {
										ctx.moveTo(0, 0);
										ctx.lineTo(n.c[i].x, n.c[i].y);
									}
									ctx.stroke();
									ctx.lineWidth = 2;
								}
							}
							
							ctx.restore();
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				ctx.restore();
			},
			
			// переключает состояние редактора из "редактирование" в "просмотр" и обратно
			runGame: function(btn) {
				if (!ed.run) {
					ed.root = Tree2d.copy(Tree2d.root);
					Tree2d.init(ed.root);
					btn.value = 'Stop';
				} else {
					delete ed.root;
					ed.root = Tree2d.root;
					btn.value = 'Run';
				}
				ed.run = !ed.run;
				console.log(ed.root);
			}
		};
		
		// выбрать случайный объект из объекта obj
		function getRandField(obj) {
			var size = 0;
			for (i in obj) if (typeof obj == 'object') {
				size++;
			}
			var n = Math.floor(Math.random() * size), k = 0;
			for (i in obj) {
				if (k == n) return obj[i];
				k++;
			}
		}
		
		// получить позицию мыши внутри canvas
		function getMousePos(canvas, evt) {
			var rect = canvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left - canvas.width / 2,
				y: evt.clientY - rect.top - canvas.height / 2
			};
		}
		
		// определяет, лежит ли точка (x, y) в полигоне с иксами вершин в xp и игреками в yp,
		// с количеством вершин npol
		function pnpoly(npol, xp, yp, x, y) {
			var i, j, c = false;
			for (i = 0, j = npol-1; i < npol; j = i++) {
				if ((((yp[i] <= y) && (y < yp[j])) ||
				     ((yp[j] <= y) && (y < yp[i]))) &&
				    (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
				    c =!c;
			}
			return c;
		}
		
		// инициализирует узел - спрайт
		function Sprite(node) {
			node.img = ed.loadImage(node.src);
			if (!node.w) node.w = node.img.width;
			if (!node.h) node.h = node.img.height;
			node.draw = function(node) {
				ctx.drawImage(node.img, -node.w / 2, -node.h / 2);
			}
		}
	}</script>
</html>
