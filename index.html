<!DOCTYPE html>
<html>
	<body onselectstart="return false"  oncontextmenu="return false">
		<div style="min-width:960px;width:77%;height:650px;overflow:scroll;float:left">
			<canvas id="myCanvas" width="512" height="512" style="border:1px solid #999999;">
				Your browser does not support the HTML5 canvas tag.
			</canvas>
		</div>
		<div style="min-width:260px;width:22%;height:650px;valign:top;float:left">
			<input type="button" value="Save"  onclick="ed.saveProject()" style="width:32%" />
			<input type="button" value="Load" onclick="document.getElementById('projectLoader').click()" style="width:32%" />
			<input type="button" value="Run" onclick="ed.runGame(this)" style="width:32%" />
			<select id="hierarhy" style="width:100%" onchange="ed.select(this.value)"></select>
			<div id="info" style="width:100%;height:40%;overflow:scroll"></div>
			<input type="button" value="Raise"  onclick="ed.raise()" style="width:23%" />
			<input type="button" value="Fall" onclick="ed.fall()" style="width:23%" />
			<input type="button" value="To asset" onclick="ed.assetFromNode(ed.selected)" style="width:23%" />
			<input type="button" value="Delete" onclick="ed.del(ed.selected)" style="width:23%" />
			<input type="range" min="0" max="100" step="5" value="0" onchange="ed.setGrid(this)" /> Grid<br />
			<input type="range" min="0" max="20" value="0" onchange="ed.setBrushRandom(this)" /> Brush random<br />
			<input type="range" min="0" max="30" step="2" value="10" onchange="ed.setBrushDelay(this)" /> Brush delay<br />
			<div style="border:1px solid gray;width:100%;height:45%;cursor:default;">
				Assets: <input type="file" id="files" name="files[]" multiple /><br />
				<div id="assets" style="width:100%;height:85%;overflow-y:scroll"></div>
			</div>
			<input type="file" id="projectLoader" style="visibility:hidden;position:absolute;top:0;left:0" />
		</div>
	</body>
	<script>{
		var canvas, ctx;
		
		onload = function() {
			canvas = document.getElementById("myCanvas");
			canvas.addEventListener('mousedown', function(evt) {if (ed.run) {Tree2d.click(getMousePos(canvas, evt))} else {if (evt.button == 0) ed.mousePress(getMousePos(canvas, evt)); else ed.pick(getMousePos(canvas, evt));}}, false);
			canvas.addEventListener('mousemove', function(evt) {if (ed.run) {Tree2d.mousemove=getMousePos(canvas, evt)} else {if (evt.button == 0) ed.mouseMove(getMousePos(canvas, evt)); else ed.drag(getMousePos(canvas, evt));}}, false);
			canvas.addEventListener('mouseup',   function(evt) {if (ed.run) {Tree2d.mouseup=getMousePos(canvas, evt)} else {if (evt.button == 0) ed.mouseRelease(getMousePos(canvas, evt)); else ed.unpick();}}, false);
			canvas.addEventListener('mouseout',   function(evt) {if (ed.run) {Tree2d.mouseup=getMousePos(canvas, evt)} else {if (evt.button == 0) ed.mouseRelease(0); else ed.unpick();}}, false);
			ctx = canvas.getContext("2d");
			document.getElementById('files').addEventListener('change', ed.load, false);
			document.getElementById('projectLoader').addEventListener('change', ed.loadProject, false);
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 2;
			ed.select(0);
			ed.renewHierarhy();
			ed.addAssetFromString('node.json', '{}');
			ed.addAssetFromString('sprite.json', '{"e":{"init":"sprite"}}');
			setInterval(ed.cycle, 10);
		}
		
		// основная либа для работы с внутриигровым деревом
		// для содержания дерева есть 2 типа связей:
		// 1. потомки node хранятся в массиве node.c
		// 2. у node есть ссылки на parent (родителя), child (первого потомка) и next (соседа)
		var Tree2d = {
			// корневой узел
			root: {
				x:0,  // позиция по Х
				y:0,  // позиция по Y
				r:0,  // поворот в градусах
				zx:1, // масштаб по горизонтали (1 - изначальный, 0.5 - в 2 раза меньше)
				zy:1, // масштаб по вертикали
				w:512, // ширина (прилаги)
				h:512, // высота (прилаги)
				a:1,  // степень непрозрачности (1 - непрозрачный, 0 - полностью прозрачный)
				id:0, // уникальный ID, по нему осуществляется поиск
				name:'root' // имя узла (по нему тоже можно искать узел в дереве)
			},
			
			backup: undefined, // для ф-ии reset
			
			mousedown: {},
			click: function(pos) {
				if (Tree2d.cameraobj) {
					pos.x -= Tree2d.cameraobj.x;
					pos.y -= Tree2d.cameraobj.y;
				}
				Tree2d.mousedown = Tree2d.getClickedObject(pos);
			},
			mousemove: {},
			mouseup: {},
			cameraobj: {},
			
			cid: 1, // текущий айдишник
			
			// генерирует уникальный айдишник - имя узла
			genId: function() {return Tree2d.cid++;},
			
			// возвращает копию указанного узла
			// рекурсивная
			copy: function(node) {
				var copy = {};
				for (var i in node) {
					if (i == 'e') {
						copy.e = {};
						for (j in node.e) {
							copy.e[j] = node.e[j];
						}
					} if (typeof node[i] === 'object' || i == 'id') {
					} else {
						copy[i] = node[i];
					}
				}
				if (node.c) {
					copy.c = [];
					for (var i in node.c) {
						if (node.c[i] && node.c[i] != null) copy.c[i] = Tree2d.copy(node.c[i]);
					}
				}
				return copy;
			},
			
			// создает дефолтные поля, если их нет
			// вызывает для каждой ноды ф-ю инициализации - имя класса
			// создает в узле ссылки на родителя, соседа и потомка
			// рекурсивная
			init: function(node) {
				if (!node.x) node.x = 0;
				if (!node.y) node.y = 0;
				if (!node.r) node.r = 0;
				if (!node.zx) node.zx = 1;
				if (!node.zy) node.zy = 1;
				if (!node.w) node.w = 0;
				if (!node.h) node.h = 0;
				if (node.a == undefined) node.a = 1;
				if (node.id == undefined) node.id = Tree2d.genId();
				Tree2d.cookUpdate(node);
				if (node.init) node.init(node);
				if (node.c) {
					var prev;
					for (var i in node.c) {
						var val = node.c[i];
						if (!val) console.log(node);
						if (!val.parent) val.parent = node;
						if (!prev) node.child = val;
						else prev.next = val;
						prev = val;
						Tree2d.init(val);
					}
				}
			},
			
			// удаляет из узла дефолтные поля
			// удаляет все внутренние объекты, кроме массива c[] (children)
			// рекурсивная
			clean: function(node) {
				if (node.x == 0) delete node.x;
				else node.x = Math.round(node.x);
				if (node.y == 0) delete node.y;
				else node.y = Math.round(node.y);
				if (node.r == 0) delete node.r;
				else node.r = Math.round(node.r);
				if (node.zx == 1) delete node.zx;
				if (node.zy == 1) delete node.zy;
				if (node.a == 1) delete node.a;
				if (node.w == 0) delete node.w;
				if (node.h == 0) delete node.h;
				if (node.id) delete node.id;
				for (var i in node) {
					if (typeof node[i] === 'number') {
						node[i] = parseFloat(node[i].toFixed(4));
					} else if (i != 'c' && i != 'e' && typeof node[i] === 'object' && !node[i].substring) {
						node[i] = 0;
						delete node[i];
					}
				}
				for (var i in node.c) {
					if (node.c[i] && node.c[i] != null) Tree2d.clean(node.c[i]);
					else delete node.c[i];
				}
				return node;
			},
			
			// добавляет node в массив с (children) родителя
			// перестраивает ссылки на следующий элемент среди потомков parent
			// инициализирует node
			add: function(parent, node) {
				node = Tree2d.copy(node) || {};
				
				if (!parent.c) parent.c = [];
				parent.c.push(node);
				node.parent = parent;
				
				if (!parent.child) {
					parent.child = node;
				} else {
					var c = parent.child;
					while (c.next) c = c.next;
					c.next = node;
				}
				Tree2d.init(node);
				
				return node;
			},
			
			// удаляет node из потомков его родителя
			del: function(node) {
				var parent = node.parent;
				if (parent) {
					for (var i in parent.c) {
						if (parent.c[i] == node) {
							parent.c[i] = 0;
							delete parent.c[i];
						}
					}
					if (parent.child == node) {
						parent.child = node.next;
					} else {
						var c = parent.child;
						while (c.next && c.next != node) c = c.next;
						c.next = node.next;
					}
				}
			},
			
			// всем потомкам родителя node, кроме node, выставляет opacity = 0
			select: function(node) {
				var c = node.parent.child;
				while (c) {
					if (c != node) c.a = 0;
					else if (c.a == 0) c.a = 1;
					c = c.next;
				}
			},
			
			// берет строку ивента line (то поле, которое после типа ивента), и делает из нее код на JS
			// автоматом преобразует 'param' в 'n.param', если в node есть поле param
			// дополняет 'Tree2d.' к ф-ям Tree2d
			// заменяет '_nodename.x' на 'Tree2d.findNodeByName("nodename").x'
			makeFunction: function(node, line) {
				var alphanumetric = /^[a-z][a-z0-9]+$/i;
				var numetric = /^[0-9]+$/;
				var noan = /^\W$/;
				line = line.split('\n').join(';');
				line = line.split('%').join('PeRcEnT');
				
				var arr = line.split(/\b/);
				for (var k in arr) {
					var next = arr[parseFloat(k)+1];
					var prev = arr[parseFloat(k)-1];
					
					if (arr[k].charAt(0) == '_') {
						arr[k] = arr[k].substr(1);
						var n = Tree2d.findByName(arr[k]);
						if (!n) {
							var text = 'Unknown node name "'+arr[k]+'" at line "'+line+'"';
							if (node.name) text = 'In node "'+node.name+'": '+text;
							alert (text);
							return '';
						}
						arr[k] = 'Tree2d.findByName("'+arr[k]+'")';
						continue;
					}
					
					if (prev && prev == '.') continue;
					
					var flag = false;
					
					for (j in node) {
						if (arr[k] == j) {
							arr[k] = 'n.' + arr[k];
							flag = true;
						}
					}
					for (j in Tree2d) {
						if (arr[k] == j) {
							arr[k] = 'Tree2d.' + arr[k];
							flag = true;
						}
					}
					
					var f = undefined;
					try {
						f = eval(arr[k]);
					} catch (e) {}
					if (typeof f == 'function' && (!next || (next && next != '('))) {
						arr[k] += '(n)';
						flag = true;
					}
					
					if (alphanumetric.test(arr[k]) && !flag) {
						var text = 'Unknown identifier "'+arr[k]+'" at line "'+line+'"';
						if (node.name) text = 'In node "'+node.name+'": '+text;
						alert (text);
						return '';
					}
				}
				line = arr.join('').split(';').join('\n');
				
				try {
					eval('(function(n){'+line+'})');
				} catch (e) {
					var text = 'Error in "'+line+'": ' + e;
					if (node.name) text = 'In node "'+node.name+'": '+text;
					alert (text);
					return '';
				}
				line = line.split('PeRcEnT').join('%');
				
				return line;
			},
			
			// подготавливает ф-ии update и init из ивентов узла
			cookUpdate: function(node) {
				if (!node.e) return;
				var str = '(function(n) {\n', cnt = 0;
				for (var i in node.e) {
					if (i == 'init') continue;
					if (i == 'box collision') str += '\nif (Tree2d.boxCollision(n)) {\n';
					if (i == 'click') str += '\nif (Tree2d.mousedown == n) {\n';
					str += Tree2d.makeFunction(node, node.e[i]);
					if (i == 'click' || i == 'box collision') str += '\n}';
					cnt++;
					str += ';';
				}
				str += '\n})';
				
				if (cnt > 0) node.update = eval(str);
				
				if (node.e.init) {
					var str = '(function(n) {\n';
					str += Tree2d.makeFunction(node, node.e.init);
					str += '\n})';
					
					node.init = eval(str);
				}
				
				return true;
			},
			
			// действия за 1 кадр: отрисовка и апдейт
			cycle: function() {
				var t = Tree2d.getScreenTransform(Tree2d.cameraobj);
				var n = Tree2d.root;
				ctx.save();
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.translate(canvas.width / 2 - t.x, canvas.height / 2 - t.y);
				while (n) {
					ctx.save();
					ctx.globalAlpha *= n.a;
					ctx.translate(n.x, n.y);
					ctx.rotate(n.r / 180 * Math.PI);
					ctx.scale(n.zx, n.zy);
					if (n.a) {
						if (n.update) n.update(n);
						if (n.draw) n.draw(n);
					}
					
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							ctx.restore();
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				ctx.restore();
				
				Tree2d.mousedown = undefined;
				Tree2d.mousemove = undefined;
				Tree2d.mouseup = undefined;
			},
			
			// если узел с ID id не найден - вернет undefined
			findById: function(id) {
				var n = Tree2d.root;
				
				while (n) {
					if (n.id == id) {
						return n;
					} else if (n.child) {
						n = n.child;
					} else {
						while (n) {
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
			},
			
			// если узел с именем name не найден - вернет undefined
			findByName: function(name, n) {
				var a = name.split('%');
				if (a.length > 1) {
					if (Tree2d.root[a[1]]) {
						a[1] = Tree2d.root[a[1]];
						name = a.join('');
					} else {
						alert('Game root has no fields named "'+a[1]+'"');
						return;
					}
				} else {
					a = name.split('PeRcEnT');
					if (a.length > 1) {
						if (Tree2d.root[a[1]]) {
							a[1] = Tree2d.root[a[1]];
							name = a.join('');
						} else {
							alert('Game root has no fields named "'+a[1]+'"');
							return;
						}
					}
				}
				
				n = n || Tree2d.root;
				if (n.name == name) return n;
				
				if (n.c) {
					for (var i in n.c) {
						var val = Tree2d.findByName(name, n.c[i]);
						if (val) return val;
					}
				}
			},
			
			reset: function(n) {
				if (!n.name) return;
				var b = Tree2d.findByName(n.name, Tree2d.backup);
				var backup = Tree2d.copy(b);
				for (i in backup) {
					if (i != 'next' && i != 'parent') {
						n[i] = backup[i];
					}
				}
				Tree2d.init(n);
			},
			
			// получить позицию, поворот, скейл и непрозрачность отрисовки узла
			getScreenTransform: function(node) {
				var trans = {x:0,y:0,zx:1,zy:1,r:0};
				var parent = node.parent;
				var x = node.x, y = node.y;
				var r = node.r;
				var zx = node.zx, zy = node.zy;
				
				while (parent) {
					var si = Math.sin(parent.r * Math.PI / 180);
					var co = Math.cos(parent.r * Math.PI / 180);
					trans.x = parent.x + (x*parent.zx*co - y*parent.zy*si);
					trans.y = parent.y + (x*parent.zx*si + y*parent.zy*co);
					trans.r = parent.r + r;
					trans.zx = parent.zx * zx;
					trans.zy = parent.zy * zy;
					
					x = trans.x;
					y = trans.y;
					r = trans.r;
					zx = trans.zx;
					zy = trans.zy;
					
					parent = parent.parent;
				}
				
				return trans;
			},
			
			// если бы точка была узлом и рисовалась бы в (pos.x, pos.y),
			// то внутри node она имела бы позицию, поворот, скейл и непрозрачность,
			// возвращенные этой ф-ей
			convertPointToNodeTransform: function(node, pos) {
				var t = Tree2d.getScreenTransform(node);
				var dx = pos.x - t.x;
				var dy = pos.y - t.y;
				var d = Math.sqrt(dx * dx + dy * dy);
				var r = Math.atan2(dy, dx) / Math.PI * 180;
				var si = Math.sin((t.r-r) * Math.PI / 180);
				var co = Math.cos((t.r-r) * Math.PI / 180);
				var x = d * co;
				var y = d * si;
				return {x:x / t.zx, y:-y / t.zy};
			},
			
			// кликнут ли объект n, при клике в позиции pos
			isObjectClicked: function(n, pos) {
				var t = Tree2d.getScreenTransform(n);
				var si = Math.sin(t.r * Math.PI / 180);
				var co = Math.cos(t.r * Math.PI / 180);
				var xp = [];
				var yp = [];
				var w = n.w / 2, h = n.w / 2;
				xp.push(t.x + t.zx * w * co - t.zy * h * si);
				yp.push(t.y + t.zx * w * si + t.zy * h * co);
				w = -w;
				xp.push(t.x + t.zx * w * co - t.zy * h * si);
				yp.push(t.y + t.zx * w * si + t.zy * h * co);
				h = -h;
				xp.push(t.x + t.zx * w * co - t.zy * h * si);
				yp.push(t.y + t.zx * w * si + t.zy * h * co);
				w = -w;
				xp.push(t.x + t.zx * w * co - t.zy * h * si);
				yp.push(t.y + t.zx * w * si + t.zy * h * co);
				
				if (pnpoly(4, xp, yp, pos.x, pos.y)) return true;
			},
			
			// тут все просто: находит кликнутый объект
			// если такого нет - возвращает undefined
			getClickedObject: function(pos) {
				var n = Tree2d.root;
				var arr = [];
				
				while (n) {
					if (n.a && n.w && n.w) arr.push(n);
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				
				arr = arr.reverse();
				for (var i in arr) {
					if (Tree2d.isObjectClicked(arr[i], pos)) {
						return arr[i];
					}
				}
			},
			
			// делает node на слой выше соседей
			// влияет на порядок отрисовки, апдейта, нахождения кликнутого узла
			raise: function(node) {
				if (node.next) Tree2d.fall(node.next);
			},
			
			// делает node на слой ниже соседей
			// влияет на порядок отрисовки, апдейта, нахождения кликнутого узла
			fall: function(node) {
				if (!node.parent) return;
				var p = node.parent, i, j;
				for (var i in p.c) {
					if (p.c[i] == node) break;
					j = i;
				}
				if (j) {
					var c = p.c[i];
					p.c[i] = p.c[j];
					p.c[j] = c;
					for (var i in p.c) if (p.c[i].next) delete p.c[i].next;
					
					var prev;
					for (var i in p.c) {
						var val = p.c[i];
						if (!val.parent) val.parent = p;
						if (!prev) p.child = val;
						else prev.next = val;
						prev = val;
					}
				}
			},
			
			// проверяет AABB столкновения для объекта n среди его соседей, попутно их решает
			boxCollision: function(n) {
				var c = n.parent.child;
				while (c) {
					if (c != n) {
						var dx = Math.abs(c.x - n.x);
						var dy = Math.abs(c.y - n.y);
						var dw = (c.w + n.w) * 0.5;
						var dh = (c.h + n.h) * 0.5;
						if (dx < dw && dy < dh) {
							if (dx > dy) {
								if (n.x < c.x) n.x = c.x - dw;
								else n.x = c.x + dw;
							} else {
								if (n.y < c.y) n.y = c.y - dh;
								else n.y = c.y + dh;
							}
							return true;
						}
					}
					c = c.next;
				}
			},
			
			//
			camera: function(node) {
				Tree2d.cameraobj = node;
			}
		}
		
		// ф-ии редактора
		var ed = {
			run: false, // запущена прилага или нет
			root: Tree2d.root, // корень, может меняться
			selected: undefined, // выделенный объект
			images: {}, // хранилище картинок (для избежания дубликатов)
			assets: {}, // хранилище ассетов (готовые узлы)
			selectedAssets: {}, // выделенные ассеты
			selectedAssetsCnt: 0, // их число
			eventTypes: ['update', 'click', 'init', 'box collision'], // типы возможных событий
			brush: { // параметры кисти
				timeout:10, // задержка действия
				ready:true,
				grid:0, // высота и ширина сетки
				random:0, // разброс относительно позиции в сетке
				drag:false, // тянем?
				t:0 // таймер, обслуживающий задержку
			},
			pickup: false,
			
			// грузит картинку, избегает дубликатов
			loadImage: function(name, data) {
				if (ed.images[name]) return ed.images[name];
				ed.images[name] = new Image;
				ed.images[name].src = data;
				//if (!ed.assets[name]) ed.loadSprite(name);
				return ed.images[name];
			},
			
			// "вписывает" картинку img в квадрат size*size
			alignAssetSize: function(img, size, name) {
				if (name) document.getElementById(name).title = name + ' ('+img.width+'x'+img.height+')';
				var d = img.width / img.height;
				if (img.width > img.height) {
					img.width = size;
					img.height = size / d;
					img.vspace = size / 2 - img.height / 2;
				} else {
					img.height = size;
					img.width = size * d;
					img.hspace = size / 2 - img.width / 2;
				}
			},
			
			// выделить ассет с именем name
			selectAsset: function(name) {
				if (!ed.selectedAssets[name]) {
					ed.selectedAssets[name] = ed.assets[name];
					ed.selectedAssetsCnt++;
					document.getElementById(name).style.border = "2px solid #6468D1";
				} else {
					ed.selectedAssets[name] = 0;
					delete ed.selectedAssets[name];
					ed.selectedAssetsCnt--;
					document.getElementById(name).style.border = "2px solid #f7f4a0";
				}
			},
			
			// грузит картинку, создает ассет с именем name
			loadSprite: function(name, file) {
				if (ed.assets[name]) return ed.assets[name];
				
				var reader = new FileReader();
				reader.onload = function(e) {
					ed.loadImage(name, e.target.result);
					ed.assets[name] = {src: name, name:name.substr(0, name.lastIndexOf('.')), e:{init:'sprite'}};
					document.getElementById('assets').innerHTML += '<div id="'+name+'" title="'+name+'" style="float:left; width:60px; height:60px; border:2px solid #f7f4a0; background-color:white;" onclick="ed.selectAsset(\''+name+'\')" ><img src="'+e.target.result+'" ondblclick="ed.placeAsset(\''+name+'\')" onload="ed.alignAssetSize(this, 60, \''+name+'\')" /></div>';
				}
				var result = reader.readAsDataURL(file);
				
				return ed.assets[name];
			},
			
			// создает ассет из строки, содержащей JSON
			addAssetFromString: function(name, str) {
				var node = JSON.parse(str);
				ed.assets[name] = node;
				
				var withoutExt = name.substr(0, name.lastIndexOf('.'));
				withoutExt = withoutExt.charAt(0).toUpperCase() + withoutExt.substr(1);
				document.getElementById('assets').innerHTML += '<div id= "'+name+'" title="'+name+'" style="float:left; width:60px; height:60px; border:2px solid #f7f4a0; background-color:white; font-size: small; text-align:center;" ondblclick="ed.placeAsset(\''+name+'\')" onclick="ed.selectAsset(\''+name+'\')" ><br />'+withoutExt+'</div>';
			},
			
			assetFromNode: function(node) {
				var name = node.name || 'asset' + node.id;
				if (ed.assets[name]) return ed.assets[name];
				ed.assets[name] = node;
				
				withoutExt = name.charAt(0).toUpperCase() + name.substr(1);
				document.getElementById('assets').innerHTML += '<div id= "'+name+'" title="'+name+'" style="float:left; width:60px; height:60px; border:2px solid #f7f4a0; background-color:white; font-size: small; text-align:center;" ondblclick="ed.placeAsset(\''+name+'\')" onclick="ed.selectAsset(\''+name+'\')" ><br />'+withoutExt+'</div>';
			},
			
			// грузит узел из файла, создает соотв. ассет с именем name
			loadNode: function(name, file) {
				if (ed.assets[name]) return ed.assets[name];
				
				var reader = new FileReader();
				reader.onload = function(e) {
					ed.addAssetFromString(name, e.target.result);
				}
				var result = reader.readAsText(file);
				
				return ed.assets[name];
			},
			
			// загрузить что-то
			load: function(evt) {
				var files = evt.target.files;
				for (var i = 0, f; f = files[i]; i++) {
					var name = f.name.substr(f.name.lastIndexOf('/') + 1);
					if (f.type == 'image/png' || f.type == 'image/jpeg') {
						ed.loadSprite(name, f);
					} else if (f.type == 'application/json') {
						ed.loadNode(name, f);
					}
				}
			},
			
			// загружает узел, устанавливает его в качестве корня
			loadProject: function(evt) {
				var file = evt.target.files[0];
				var withoutExt = file.name.substr(0, file.name.lastIndexOf('.'));
				
				var reader = new FileReader();
				reader.onload = function(e) {
					var node = JSON.parse(e.target.result);
					ed.root = Tree2d.root = node;
					Tree2d.init(node);
					
					ed.renewHierarhy();
					ed.select(node.id);
					
					canvas.width = node.w;
					canvas.height = node.h;
				}
				var result = reader.readAsText(file);
			},
			
			// выплевывает файл .json, названный как корень, содержащий иерархию сцены в JSON
			saveProject: function() {
				var c = Tree2d.clean(Tree2d.copy(Tree2d.root));
				var text = JSON.stringify(c);
				text = text.split(',null').join('');
				var pom = document.createElement('a');
				pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
				pom.setAttribute('download', ed.root.name + '.json');
				pom.setAttribute('type', 'application/json');
				pom.click();
			},
			
			// обрабатывает нажатие левой кнопки мыши
			mousePress: function(pos) {
				if (ed.selectedAssetsCnt == 0) {
					ed.pickup = true;
					if (ed.selected.parent) {
						ed.tmpMousePos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
						ed.tmpSelectedTrans = {x: ed.selected.x, y: ed.selected.y, r: ed.selected.r, zx: ed.selected.zx, zy:ed.selected.zy};
					}
				} else {
					ed.brush.drag = true;
					if (!ed.brush.grid) ed.brush.grid = 1;
					if (!ed.grid) ed.grid = 1;
					if (ed.selected != ed.root) pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					pos.x = Math.round((pos.x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
					pos.y = Math.round((pos.y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
					pos.x += Math.random() * ed.brush.random * 2 - ed.brush.random;
					pos.y += Math.random() * ed.brush.random * 2 - ed.brush.random;
					ed.brush.dragPos = pos;
					ed.pasteAsset(pos);
					ed.brush.t = ed.brush.timeout;
				}
			},
			
			// перемещение мыши с удержанной левой кнопкой
			mouseMove: function(pos) {
				if (ed.pickup && ed.selected.parent) {
					if (!ed.brush.grid) ed.brush.grid = 1;
					pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					if (event.shiftKey) {
						var dx1 = ed.tmpMousePos.x - ed.tmpSelectedTrans.x;
						var dy1 = ed.tmpMousePos.y - ed.tmpSelectedTrans.y;
						var d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
						var dx2 = pos.x - ed.tmpSelectedTrans.x;
						var dy2 = pos.y - ed.tmpSelectedTrans.y;
						var d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
						var d = d2 / d1;
						ed.set('zx', ed.tmpSelectedTrans.zx * d);
						ed.set('zy', ed.tmpSelectedTrans.zy * d);
					} else if (event.ctrlKey) {
						var r = Math.atan2(pos.y - ed.tmpSelectedTrans.y, pos.x - ed.tmpSelectedTrans.x) / Math.PI * 180;
						ed.set('r', ed.tmpSelectedTrans.r + r);
					} else {
						var x = ed.tmpSelectedTrans.x + (pos.x - ed.tmpMousePos.x);
						var y = ed.tmpSelectedTrans.y + (pos.y - ed.tmpMousePos.y);
						var x1 = Math.round((x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						var y1 = Math.round((y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						if (Math.abs(x1 - x) < 10) x = x1;
						if (Math.abs(y1 - y) < 10) y = y1;
						ed.set('x', x);
						ed.set('y', y);
					}
				} else if (ed.brush.drag && ed.brush.ready) {
					if (ed.brush.t > 0) {
						ed.brush.t--;
						return;
					}
					if (ed.selected != ed.root) pos = Tree2d.convertPointToNodeTransform(ed.selected.parent, pos);
					if (Math.abs(pos.x - ed.brush.dragPos.x) > ed.brush.grid * 0.75 || Math.abs(pos.y - ed.brush.dragPos.y) > ed.brush.grid * 0.75) {
						if (!ed.grid) ed.grid = 1;
						pos.x = Math.round((pos.x + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						pos.y = Math.round((pos.y + ed.brush.grid / 2) / ed.brush.grid) * ed.brush.grid;
						pos.x += Math.random() * ed.brush.random* 2 - ed.brush.random;
						pos.y += Math.random() * ed.brush.random * 2 - ed.brush.random;
						ed.brush.dragPos = pos;
						ed.pasteAsset(pos);
					}
					ed.brush.t = ed.brush.timeout;
				}
			},
			
			// отпускание левой кнопки мыши
			mouseRelease: function(pos) {
				ed.brush.drag = false;
				ed.pickup = false;
			},
			
			// нажатие правой кнопки мыши
			pick: function(pos) {
				var c = Tree2d.getClickedObject(pos);
				if (ed.selectedAssetsCnt == 0) {
					if (c) ed.select(c.id);
					else ed.select(Tree2d.root.id);
				} else {
					if (c && c.parent == ed.selected) ed.del(c);
				}
			},
			
			// "перетаскивание" с нажатой правой кнопкой мыши
			drag: function(pos) {
				if (ed.selectedAssetsCnt != 0) {
					var c = Tree2d.getClickedObject(pos);
					if (c && c.parent == ed.selected) ed.del(c);
				}
			},
			
			// отпускание правой кнопки мыши
			unpick: function() {
			},
			
			// вставляет один из выделенных ассетов в выделенный узел на позиции pos
			pasteAsset: function(pos) {
				pos = pos || {x: 0, y: 0};
				var c = getRandField(ed.selectedAssets);
				pos = Tree2d.convertPointToNodeTransform(ed.selected, pos);
				c.x = pos.x;
				c.y = pos.y;
				Tree2d.add(ed.selected, c);
				ed.renewHierarhy();
			},
			
			// удаляет узел c из иерархии
			del: function(c) {
				if (!c.parent) return;
				if (c == ed.selected) ed.select(ed.selected.parent.id);
				Tree2d.del(c);
				ed.renewHierarhy();
			},
			
			// устанавливает размер сетки input.value
			setGrid: function(input) {
				ed.brush.grid = parseFloat(input.value);
				input.title = ed.brush.grid;
			},
			
			// устанавливает задержку кисти input.value
			setBrushDelay: function(input) {
				ed.brush.timeout = parseFloat(input.value);
				input.title = ed.brush.timeout;
			},
			
			// устанавливает разброс кисти input.value
			setBrushRandom: function(input) {
				ed.brush.random = parseFloat(input.value);
				input.title = ed.brush.random;
			},
			
			// поднимает выделенную ноду наверх (вниз по иерархии)
			raise: function() {
				Tree2d.fall(ed.selected);
				ed.renewHierarhy();
				ed.select(ed.selected.id);
			},
			
			// опускает выделенную ноду на слой ниже (вверх по иерархии)
			fall: function(node) {
				Tree2d.raise(ed.selected);
				ed.renewHierarhy();
			},
			
			// обновляет выпадающий список иерархии
			renewHierarhy: function() {
				var n = Tree2d.root, str = '', t = -1;
				
				while (n) {
					t++;
					
					var s = '', i = 0;
					for (var i = 0; i < t; i++) s += '-';
					var name = n.name;
					if (!n.name || name == '')  name = '';
					else name = ' ' + name;
					if (n.e && n.e.init) name += ' [' + n.e.init + ']';
					else name += ' [layer]';
					str += '<option value="' + n.id + '">' + s + name + '</option>\n';
					
					if (n.child) {
						n = n.child;
					} else {
						while (n) {
							t--;
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				
				document.getElementById('hierarhy').innerHTML = str;
				document.getElementById('hierarhy').value = ed.selected.id;
			},
			
			// выделяет ноду с ID = id
			select: function(id) {
				id = parseFloat(id);
				ed.selected = Tree2d.findById(id);
				document.getElementById('hierarhy').value = id;
				ed.updateInfo();
			},
			
			// устанавливает параметр param выделенной ноды равным value
			set: function(param, value) {
				var node = ed.selected;
				if (param == 'a') {
					if (typeof value == 'number') {
						node.a = value;
						document.getElementById('edit-a').value = node.a;
						document.getElementById('edit-a-checkbox').checked = (node.a>0?true:false);
					} else {
						node.a = value?1:0;
						document.getElementById('edit-a').value = node.a;
						document.getElementById('edit-a-checkbox').checked = (node.a>0?true:false);
					}
				} else if (typeof node[param] === 'number') {
					if (typeof parseFloat(value) === 'number') {
						node[param] = parseFloat(value);
						if (node == ed.root && (param == 'w' || param == 'h')) {
							canvas.width = node.w;
							canvas.height = node.h;
						}
					}
					document.getElementById('edit-'+param).value = node[param];
					if (document.getElementById('edit-'+param+'-checkbox')) document.getElementById('edit-'+param+'-checkbox').checked = (node[param]>0?true:false);
				} else node[param] = value;
				if (param == 'name') ed.renewHierarhy();
				Tree2d.init(ed.selected);
			},
			
			// обновляет блок информации о ноде
			updateInfo: function() {
				var node = ed.selected;
				var excluded = ['id', 'class'];
				var str = '\
				<input type="text" value="Name" readonly style="width:80px" /><input type="text" onclick="this.select()" onchange="ed.set(\'name\',this.value)" id="edit-name" value="'+(node.name?node.name:'')+'" /><br />\
				<input type="text" value="Position" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'x\',this.value)" id="edit-x" value="'+node.x+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'y\',this.value)" id="edit-y" value="'+node.y+'" /><br />\
				<input type="text" value="Scale" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'zx\',this.value)" id="edit-zx" value="'+node.zx+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'zy\',this.value)" id="edit-zy" value="'+node.zy+'" /><br />\
				<input type="text" value="Bounds" readonly style="width:80px" /><input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'w\',this.value)" id="edit-w" value="'+node.w+'" />\
				<input style="width:80px" type="number" onclick="this.select()" onchange="ed.set(\'h\',this.value)" id="edit-h" value="'+node.h+'" /><br />\
				<input type="text" value="Rotation" readonly style="width:80px" /><input type="number" onclick="this.select()" onchange="ed.set(\'r\',this.value)" id="edit-r" value="'+node.r+'" /><br />\
				<input type="text" value="Opacity" readonly style="width:80px" /><input type="range" onchange="ed.set(\'a\',this.value)" id="edit-a" min="0" max="1" step="0.05" value="'+node.a+'" />\
				<input type="checkbox" onclick="this.select()" onchange="ed.set(\'a\',this.checked)" id="edit-a-checkbox" '+(node.a>0?"checked":"")+' /><br />';
				
				str += '<table>';
				for (var i in node) {
					var flag = false;
					for (j in excluded) if (i == excluded[j]) flag = true;
					if (flag) continue;
					if (i == 'x' || i == 'y' || i == 'r' || i == 'zx' || i == 'zy' || i == 'a' || i == 'w' || i == 'h') {
					} else if (typeof node[i] == 'number' && i != 'id') {
						var name = i;
						str += '<tr><td><input type="text" value="'+name+'" readonly style="width:80px" /></td><td><input type="number" onclick="this.select()" onchange="ed.set(\''+i+'\',this.value)" id="edit-'+i+'" value='+node[i]+' /></td><td><input type="button" value="-" onclick="ed.deleteAttr(\''+name+'\')"></td></tr>';
					}
				}
				for (var i in node) {
					var flag = false;
					for (j in excluded) if (i == excluded[j]) flag = true;
					if (flag) continue;
					if (typeof node[i] == 'string' && i != 'name') {
						var name = i;
						str += '<tr><td><input type="text" value="'+name+'" readonly style="width:80px" /></td><td><input type="text" onclick="this.select()" onchange="ed.set(\''+i+'\',this.value)" id="edit-'+i+'" value='+node[i]+' /></td></tr>';
					}
				}
				str += '</table><input id="addAttributeName" type="text" placeholder="key" onkeydown="ed.trySubmit(event, \'addAttrBtn\')" /><input id="addAttrBtn" type="button" value="Add" onclick="ed.addAttribute()" /><br />';
				
				str += 'Events:<br /><table>';
				excluded = [];
				if (node.e) {
					for (var i in node.e) {
						str += '<tr><td><input type="text" value="'+i+'" readonly style="width:80px" /></td><td><input type="text" onclick="this.select()" onchange="ed.setEvent(\''+i+'\', this.value)" value='+node.e[i]+' /></td><td><input type="button" value="-" onclick="ed.deleteEvent(\''+i+'\')"></td></tr>';
						excluded.push(i);
					}
				}
				str += '</table>';
				
				var tmpstr = '';
				for (var i in ed.eventTypes) {
					var name = ed.eventTypes[i];
					var flag = true;
					for (j in excluded) {
						if (name == excluded[j]) {
							flag = false;
						}
					}
					if (!flag) continue;
					tmpstr += '<option value="'+name+'">'+name+'</option>';
				}
				if (tmpstr && tmpstr != '') {
					str += '<select id="addEventType">';
					str += tmpstr;
					str += '</select><input type="button" value="Add" onclick="ed.addEvent()" />';
				}
				
				document.getElementById('info').innerHTML = str;
				
				Tree2d.cookUpdate(node);
			},
			
			// устанавливает выделеной ноде обработчик ивента, заодно компилит его и проверяет
			setEvent: function(name, val) {
				ed.selected.e[name] = val;
				Tree2d.init(ed.selected);
				ed.updateInfo();
			},
			
			// удаляет из выделенной ноды ивент
			deleteEvent: function(name) {
				delete ed.selected.e[name];
				Tree2d.init(ed.selected);
				ed.updateInfo();
			},
			
			// добавляет в выделенную ноду ивент с пустым обработчиком
			addEvent: function() {
				var name = document.getElementById('addEventType').value;
				if (!ed.selected.e) ed.selected.e = {};
				ed.selected.e[name] = '';
				ed.updateInfo();
			},
			
			// удаляет из выделенной ноды поле с именем name
			deleteAttr: function(name) {
				delete ed.selected[name];
				ed.updateInfo();
			},
			
			// обрабатывает нажатие Enter в поле ввода
			trySubmit: function(event, id) {
				if (event.keyCode == 13) {
					document.getElementById(id).click();
				}
			},
			
			// добавляет в выделенную ноду поле
			addAttribute: function() {
				var name = document.getElementById('addAttributeName').value;
				var excluded = ['x', 'y', 'r', 'w', 'h', 'zx', 'zy', 'a', 'src', 'id', 'class', 'update', 'draw', 'init'];
				for (var i in excluded) {
					if (excluded[i] == name) {
						alert('Attribute name '+name+' is reserved.');
						return;
					}
				}
				ed.selected[name] = 0;
				ed.updateInfo();
			},
			
			// вставляет ассет с именем name в выделенную ноду на позиции (0, 0)
			placeAsset: function(name) {
				var c = Tree2d.add(ed.selected, ed.assets[name]);
				ed.select(c.id);
				ed.renewHierarhy();
			},
			
			// действия за кадр: отрисовка и мб обработка
			cycle: function() {
				var t = Tree2d.getScreenTransform(Tree2d.cameraobj);
				var n = Tree2d.root;
				ctx.save();
				ctx.strokeStyle = 'red';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				if (ed.run) ctx.translate(canvas.width / 2 - t.x, canvas.height / 2 - t.y);
				else ctx.translate(canvas.width / 2, canvas.height / 2);
				while (n) {
					ctx.save();
					ctx.translate(n.x, n.y);
					ctx.rotate(n.r / 180 * Math.PI);
					ctx.scale(n.zx, n.zy);
					ctx.globalAlpha *= n.a;
					if (n.a) {
						if (ed.run && n.update) n.update(n);
						if (n.debugDraw) n.debugDraw(n);
						else if (n.draw) n.draw(n);
					}
					
					if (n.a && n.child) {
						n = n.child;
					} else {
						while (n) {
							if (!ed.run) {
								ctx.strokeRect(-n.w / 2 - 1, -n.h / 2 - 1, n.w + 1, n.h + 1);
								if (n == ed.selected) {
									ctx.beginPath();
									ctx.moveTo(-n.w / 2, -n.h / 2);
									ctx.lineTo(n.w / 2, n.h / 2);
									ctx.moveTo(-n.w / 2, n.h / 2);
									ctx.lineTo(n.w / 2, -n.h / 2);
									ctx.stroke();
								}
								if (n == ed.selected && n.c) {
									ctx.lineWidth = 1;
									ctx.beginPath();
									for (var i in n.c) {
										ctx.moveTo(0, 0);
										ctx.lineTo(n.c[i].x, n.c[i].y);
									}
									ctx.stroke();
									ctx.lineWidth = 2;
								}
							}
							
							ctx.restore();
							if (n.next) {
								n = n.next;
								break;
							}
							n = n.parent;
						}
					}
				}
				ctx.restore();
				
				Tree2d.mousedown = undefined;
				Tree2d.mousemove = undefined;
				Tree2d.mouseup = undefined;
			},
			
			// переключает состояние редактора из "редактирование" в "просмотр" и обратно
			runGame: function(btn) {
				if (!ed.run) {
					ed.run = true;
					ctx.save();
					Tree2d.root = Tree2d.copy(ed.root);
					Tree2d.backup = Tree2d.copy(Tree2d.root);
					Tree2d.init(Tree2d.root);
					btn.value = 'Stop';
				} else {
					ed.run = false;
					ctx.restore();
					delete Tree2d.root;
					Tree2d.root = ed.root;
					btn.value = 'Run';
				}
				console.log(Tree2d.root);
			}
		};
		
		// выбрать случайный объект из объекта obj
		function getRandField(obj) {
			var size = 0;
			for (var i in obj) if (typeof obj === 'object') {
				size++;
			}
			var n = Math.floor(Math.random() * size), k = 0;
			for (var i in obj) {
				if (k == n) return obj[i];
				k++;
			}
		}
		
		// получить позицию мыши внутри canvas
		function getMousePos(canvas, evt) {
			var rect = canvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left - canvas.width / 2,
				y: evt.clientY - rect.top - canvas.height / 2
			};
		}
		
		// определяет, лежит ли точка (x, y) в полигоне с иксами вершин в xp и игреками в yp,
		// с количеством вершин npol
		function pnpoly(npol, xp, yp, x, y) {
			var i, j, c = false;
			for (var i = 0, j = npol-1; i < npol; j = i++) {
				if ((((yp[i] <= y) && (y < yp[j])) ||
				     ((yp[j] <= y) && (y < yp[i]))) &&
				    (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
				    c =!c;
			}
			return c;
		}
		
		// инициализирует узел - спрайт
		function sprite(node) {
			if (!node.src) node.src = '#ffffff';
			if (node.src.charAt(0) == '#') {
				node.draw = function(node) {
					ctx.fillStyle = node.src;
					ctx.fillRect(-node.w / 2, -node.h / 2, node.w, node.h);
				}
			} else if (node.src && node.src != '') {
				node.img = ed.loadImage(node.src);
				if (!node.w) node.w = node.img.width;
				if (!node.h) node.h = node.img.height;
				node.draw = function(node) {
					ctx.drawImage(node.img, -node.img.width / 2, -node.img.height / 2);
				}
			}
		}
		
		function interpolateDegrees(start, end, amount) {
			var difference = Math.abs(end - start);
			if (difference > 180) {
				if (end > start) {
					start += 360;
				} else {
					end += 360;
				}
			}
			
			return (start + ((end - start) * amount));
		}
		
		function animation(node) {
			node.update = function(node) {
				var f = node.f;
				var n = node.n;
				if (!f || !n || node.tmp.t > f.time) {
					if (node.f) {
						node.f.x = node.tmp.x;
						node.f.y = node.tmp.y;
						node.f.zx = node.tmp.zx;
						node.f.zy = node.tmp.zy;
						node.f.r = node.tmp.r;
						node.f.a = node.tmp.a;
					}
					node.f = node.n;
					if (!node.f) node.f = node.child;
					node.n = node.f.next;
					if (!node.n) {
						node.f = node.child;
						node.n = node.f.next;
					}
					node.tmp.t = 0;
					if (!node.f.time) node.f.time = node.frameTime;
					Tree2d.select(node.f);
					if (node.f) {
						node.tmp.x = node.f.x;
						node.tmp.y = node.f.y;
						node.tmp.zx = node.f.zx;
						node.tmp.zy = node.f.zy;
						node.tmp.r = node.f.r;
						node.tmp.a = node.f.a;
						node.f.x = 0;
						node.f.y = 0;
						node.f.zx = 1;
						node.f.zy = 1;
						node.f.r = 0;
						node.f.a = 1;
					}
				} else {
					f = node.tmp;
					var dt = node.tmp.t / node.f.time;
					node.x = f.x + (n.x - f.x) * dt;
					node.y = f.y + (n.y - f.y) * dt;
					node.zx = f.zx + (n.zx - f.zx) * dt;
					node.zy = f.zy + (n.zy - f.zy) * dt;
					node.r = interpolateDegrees(f.r, n.r, dt);
					node.a = f.a + (n.y - f.a) * dt;
					node.tmp.t += node.speed;
				}
			}
			node.tmp = {t:0, x:0, y:0, r:0, zx:1, zy:1, a:1};
		}
	}</script>
</html>
